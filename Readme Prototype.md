# Реалізація патернів "Прототип" і "Будівельник"

## 1. Вступ

Розглянемо два важливих шаблони проектування (патерни): **"Прототип"** та **"Будівельник"**. Вони дозволяють ефективно створювати об'єкти та управляти їхньою конфігурацією без безпосередньої прив'язки до конкретних класів.

### 1.1. Патерн "Прототип"
**Прототип** є патерном проєктування, який дозволяє створювати нові об'єкти шляхом копіювання вже існуючих замість створення їх з нуля. Це особливо корисно, коли створення об'єкта є складним або витратним за ресурсами процесом. Реалізація цього підходу ґрунтується на використанні методу `clone()`, який відповідає за створення глибокої копії екземпляра класу.

Глибоке копіювання означає, що не тільки сам об'єкт, але й усі вкладені об'єкти також створюються заново, що запобігає небажаному спільному використанню змінюваних даних між оригіналом і копією. Таким чином, прототип дозволяє гнучко створювати нові об'єкти без необхідності залежати від їхніх конкретних класів або використання конструктора, що може містити складну логіку ініціалізації.

### 1.2. Патерн "Будівельник"
**Будівельник** — це шаблон проєктування, який використовується для створення складних об'єктів покроково. Він надає механізм для встановлення окремих властивостей об'єкта, що дає змогу налаштовувати його параметри перед створенням. Головна ідея полягає в тому, щоб відокремити процес конструювання об'єкта від його представлення, що робить код більш гнучким і зручним для використання.

Основним компонентом шаблону є клас Будівельника, який містить набір методів для поступового задання параметрів об'єкта. Кожен метод змінює певну характеристику або додає певний елемент до майбутнього об'єкта. Після встановлення всіх необхідних параметрів викликається метод побудови, який повертає готовий екземпляр.

Такий підхід дозволяє легко змінювати конфігурацію об'єкта, оскільки створення не відбувається одразу, а розбивається на декілька етапів. Це особливо корисно, коли об'єкт має багато параметрів або варіантів конфігурації, що може ускладнити використання звичайного конструктора. Також шаблон спрощує розширення функціональності, оскільки можна додати нові методи для встановлення додаткових характеристик без зміни основного коду.

Будівельник часто використовується для створення складних структур, таких як документи, меню, звіти або об'єкти в іграх, де потрібно задавати численні параметри перед створенням.

## 2. Реалізація патерна "Прототип"

### 2.1. Код
```python
import copy

class BookPrototype:
    """ Прототип книги """
    def __init__(self, title, author, price):
        self.title = title  # Назва книги
        self.author = author  # Автор книги
        self.price = price  # Ціна книги

    def clone(self):
        """ Створює глибоку копію книги """
        return copy.deepcopy(self)

    def get_info(self):
        """ Повертає інформацію про книгу """
        return f'Книга: "{self.title}" - {self.author}, ${self.price:.2f}'

# Створення початкового екземпляра книги
original_book = BookPrototype("1984", "Джордж Орвелл", 12.99)

# Клонування книги
cloned_book = original_book.clone()
cloned_book.price = 9.99  # Зміна ціни для копії

# Виведення інформації
print(original_book.get_info())  # Книга: "1984" - Джордж Орвелл, $12.99
print(cloned_book.get_info())    # Книга: "1984" - Джордж Орвелл, $9.99
```

### 2.2. Пояснення коду

## Клас `BookPrototype`

- **Конструктор `__init__`** ініціалізує об'єкт книги з трьома параметрами: `title` (назва), `author` (автор) і `price` (ціна).
- **Метод `clone()`** створює **глибоку копію** (`deepcopy`) об'єкта, що гарантує копіювання вкладених структур.
- **Метод `get_info()`** повертає відформатований рядок з інформацією про книгу.

## Створення початкового екземпляра

```python
original_book = BookPrototype("1984", "Джордж Орвелл", 12.99)
```
Це оригінальний об'єкт, що містить інформацію про книгу "1984".

## Клонування

```python
cloned_book = original_book.clone()
```
Тепер `cloned_book` є новим об'єктом, який містить ті ж дані, що й `original_book`.

## Зміна атрибута `price` у клоні

```python
cloned_book.price = 9.99
```
Це не впливає на `original_book`, оскільки `clone()` створює **повністю незалежний об'єкт**.

## Перевірка результату

```python
print(original_book.get_info())  # Книга: "1984" - Джордж Орвелл, $12.99
print(cloned_book.get_info())    # Книга: "1984" - Джордж Орвелл, $9.99
```
Як бачимо, зміна ціни вплинула лише на `cloned_book`, а оригінал залишився незмінним.

---

## 3. Декомпозиція завдання з використанням "Прототипа"

У цьому рівні додаємо **клас каталогу**, що дозволяє зберігати список книг і взаємодіяти з ними.

### 3.1. Код
```python
class Catalog:
    """ Каталог книг """
    def __init__(self):
        self.books = []  # Ініціалізація списку книг
    
    def add_book(self, book):
        """ Додає книгу до каталогу """
        self.books.append(book)
    
    def list_books(self):
        """ Повертає список інформації про всі книги """
        return [book.get_info() for book in self.books]

# Використання каталогу
catalog = Catalog()
catalog.add_book(original_book)
catalog.add_book(cloned_book)

for book in catalog.list_books():
    print(book)
```

### 3.2. Пояснення коду

#### **Клас `Catalog`**
Клас `Catalog` використовується для управління колекцією книг. Він дозволяє додавати книги до каталогу та отримувати список усіх збережених книг.  
Завдяки цьому класу можна створити централізовану систему зберігання та керування книжковими записами.

#### **Метод `__init__()`**
Метод ініціалізації `__init__()` створює новий екземпляр класу `Catalog`.  
При створенні об'єкта каталогу (`catalog = Catalog()`) автоматично створюється порожній список `self.books`,  
який слугує сховищем для об'єктів книг.  

**Приклад:**  
```python
catalog = Catalog()  # Створення порожнього каталогу
print(catalog.books)  # Виведе: []
```
Цей список буде заповнюватися екземплярами книг у майбутньому.

Метод add_book(book)
Метод `add_book(book)` приймає об'єкт книги та додає його до списку `self.books`.
Цей метод дозволяє зберігати в каталозі різні книги, які можуть бути як оригінальними, так і клонованими копіями.

Приклад:
```
catalog.add_book(original_book)  # Додаємо книгу
catalog.add_book(cloned_book)  # Додаємо клон книги
```
Після виконання цих команд список `self.books` міститиме два об'єкти книг.

Метод list_books()
Метод `list_books()` проходить по всіх книгах у списку `self.books` та повертає їх інформацію у вигляді списку.
Він використовує метод `book.get_info()` кожного об'єкта книги, щоб отримати опис книги.

Приклад:
```
for book in catalog.list_books():
    print(book)  # Виведе інформацію про всі книги в каталозі
Тобто, якщо в каталозі є дві книги, результат буде таким:

Назва: "Гаррі Поттер", Автор: "Дж. К. Ролінг"
Назва: "Гаррі Поттер (Копія)", Автор: "Дж. К. Ролінг"
```
Цей метод корисний для перегляду вмісту каталогу та подальшої обробки даних.

Загальний підсумок
Клас Catalog дозволяє:
- Зберігати книги у структурованому списку.
- Додавати книги до каталогу.
- Отримувати список усіх книг з інформацією про них. Таким чином, він забезпечує зручний механізм роботи з книгами в рамках патерна "Прототип".

---

## 4. Використання патернів "Прототип" та "Будівельник"

На цьому етапі додаємо можливість **створювати книги поетапно** за допомогою "Будівельника".

### 4.1. Код
```python
class BookBuilder:
    """ Будівельник для створення книги """
    def __init__(self):
        self.reset()
    
    def reset(self):
        """ Очищує створення нового об'єкта книги """
        self._book = BookPrototype("", "", 0.0)
    
    def set_title(self, title):
        """ Встановлює назву книги """
        self._book.title = title
        return self
    
    def set_author(self, author):
        """ Встановлює автора книги """
        self._book.author = author
        return self
    
    def set_price(self, price):
        """ Встановлює ціну книги """
        self._book.price = price
        return self
    
    def build(self):
        """ Завершує створення об'єкта книги """
        book = self._book
        self.reset()
        return book

# Використання будівельника
builder = BookBuilder()
new_book = (builder.set_title("Гаррі Поттер")
                   .set_author("Дж. Роулінг")
                   .set_price(20.99)
                   .build())

print(new_book.get_info())  # Книга: "Гаррі Поттер" - Дж. Роулінг, $20.99
```

### 4.2. Пояснення коду
1. `reset()` ініціалізує новий пустий об'єкт `BookPrototype`.
2. `set_title()`, `set_author()`, `set_price()` дозволяють задавати параметри книги та повертають **той же екземпляр будівельника** (`return self`), що дозволяє **використовувати ланцюжковий виклик**.
3. `build()` повертає готовий об'єкт і знову викликає `reset()`, щоб будівельник був готовий до створення нової книги.

---

## 5. Висновки

У цій роботи реалізували:
1. **Патерн "Прототип"**, що дозволяє швидко створювати копії об'єктів.
2. **Патерн "Будівельник"**, що дає змогу покроково конфігурувати складні об'єкти.
3. **Декомпозицію завдання**, що покращує підтримку та гнучкість коду.

🚀 Завдяки цим підходам, код став **масштабованим** і **зручним для розширення**!
